[{"content":" 下载源代码\r从nmap官方网站下载源代码: nmap,这里我下载的是nmap7.95版本.tar.bz2 (bzip2 压缩)\n1 2 3 4 # 解压 bzip2 -cd nmap-7.95.tar.bz2 | tar xvf - # 进入创建的目录 cd nmap-7.95 配置编译环境\r在编译之前，运行 configure 脚本来配置编译环境。\n1 ./configure ./configure 中有几个重要的参数\n--prefix=\u0026lt;directoryname\u0026gt; 决定了 Nmap 及其组件的安装位置 --without-zenmap 此选项可不安装 Zenmap 图形GUI，zenmap依赖python环境 --with-openssl=\u0026lt;directoryname\u0026gt; 链接openssl库 --with-libpcap=\u0026lt;directoryname\u0026gt; Nmap 使用Libpcap 库来捕获原始 IP 数据包 --with-libpcre=\u0026lt;directoryname\u0026gt; PCRE 是一个与 Perl 兼容的正则表达式库 --with-libdnet=\u0026lt;directoryname\u0026gt; Libdnet 是一个网络库，支持数据包操作 这里我不需要可视化gui，所以指定了\u0026ndash;without-zenmap`\n1 ./configure --prefix=/usr/local/nmap7.95 --without-zenmap 可能遇到的问题\r","date":"2024-09-13T14:44:31+08:00","permalink":"http://localhost:1313/p/arm-nmap-compile/","title":"ARM架构下编译安装nmap7.95"},{"content":" 在python中删除列表中元素是比较常见的操作，删除的方法也比较多，这里列一下最常见的做法\npop方法\rpop()方法用于删除指定位置的元素，默认删除最后一个元素，返回值为该元素。如果索引超出范围，引发IndexError异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;] # 删除索引为1的元素 remove_element = l.pop(1) print(remove_element) # lisi print(l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;] # 删除最后一个元素 remove_element = l.pop() print(remove_element) # zhaoliu print(l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;] # 删除超过索引的元素 remove_element = l.pop(10) # IndexError: pop index out of range 注意：\n需要知道要删除元素的指定索引位置。 索引超出范围，会抛出异常 使用场景\n适用于需要删除特定位置元素的场景，尤其是删除最后一个元素时。 remove方法\rremove()方法用于删除匹配到的第一个元素，无返回值。如果要删除的元素不存在，引发ValueError异常\n1 2 3 4 5 6 7 8 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除lisi l.remove(\u0026#39;lisi\u0026#39;) print(l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除不存在的元素 l.remove(\u0026#39;xxx\u0026#39;) # ValueError: list.remove(x): x not in list 注意：\nremove只会删除第一个匹配到的元素，如果有多个相同的元素要删除，那么remove就不太适用 删除不存在的元素，会抛出异常 使用场景\n适用于删除已知值的元素，且列表中该值不重复或只需删除第一个匹配项的场景。 del语句\rdel和pop()方法类似，都是用于删除指定索引位置的元素，但是del更灵活一些，可以删除指定位置的切片，索引超出范围，会引发IndexError异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除索引为1的元素 del l[1] print(l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除索引0-2的切片 del l[0:2] print(l) # [\u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除不存在的索引 del l[100] print(l) # IndexError: list assignment index out of range 注意：\n要知道要删除元素的指定索引位置 索引超出范围，会抛出异常 使用场景\n适用于删除特定位置或范围内的元素。 列表推导式\r可以创建一个新列表，用于删除想删除的元素，比较灵活\n1 2 3 4 5 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除lisi new_l = [element for element in l if element != \u0026#39;lisi\u0026#39;] print(new_l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;] 注意：\n这种方式不能原地删除，需要创建新列表，开辟新的内存空间 列表非常大的情况，效率比较低，内存占用比较大 使用场景\n适用于需要删除多个相同元素或复杂条件删除的场景。 filter函数\rfilter函数和列表推导式方式很像，但是filter函数是一个迭代器，内存效率高，处理大数据集时更高效\n1 2 3 4 5 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除lisi new_l = list(filter(lambda x: x != \u0026#39;lisi\u0026#39;, l)) print(new_l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;] 注意：\n这种方式不能原地删除，需要创建新列表，开辟新的内存空间 使用场景\n适用于需要删除多个相同元素或复杂条件删除的场景，尤其是处理大数据集时。 总结\r方法 使用场景 优点 缺点 pop 删除特定位置元素，尤其是最后一个元素 操作简单，返回被删除的元素 需要知道索引，索引超出范围会抛出异常 remove 删除已知值的元素 不需要知道索引 只能删除第一个匹配项，删除不存在的元素会抛出异常 del 删除特定位置或范围内的元素 可以删除切片，灵活性高 需要知道索引，索引超出范围会抛出异常 列表推导式 删除多个相同元素或复杂条件删除 灵活性高 需要创建新列表，内存占用较大，处理大数据集时效率较低 filter 删除多个相同元素或复杂条件删除，处理大数据集 内存效率高，适合处理大数据集 需要创建新列表，不能原地删除 ","date":"2024-09-03T19:28:27+08:00","permalink":"http://localhost:1313/p/python-list-remove/","title":"Python 列表删除元素"},{"content":" 在shell脚本中比较版本号大小是一种常见的任务，尤其是在漏洞检测中，对比版本号，判断漏洞是否存在。版本号通常由主版本号、次版本号和补丁号组成，格式可能是major.minor.patch。有时，版本号可能还包括预发布标签（如alpha或beta）或构建元数据。\n以下是一个示例shell脚本，用于比较两个版本号的大小：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #!/bin/bash # 比较两个版本号的函数 compare_versions() { local version1=$1 local version2=$2 # 将版本号分割成数组 IFS=\u0026#39;.\u0026#39; read -r -a ver1 \u0026lt;\u0026lt;\u0026lt; \u0026#34;$version1\u0026#34; IFS=\u0026#39;.\u0026#39; read -r -a ver2 \u0026lt;\u0026lt;\u0026lt; \u0026#34;$version2\u0026#34; # 获取最大数组长度 local max_len=${#ver1[@]} if [ ${#ver2[@]} -gt $max_len ]; then max_len=${#ver2[@]} fi # 比较每一部分 for ((i=0; i\u0026lt;max_len; i++)); do # 如果某个版本号部分不存在，则视为0 local part1=${ver1[i]:-0} local part2=${ver2[i]:-0} if ((part1 \u0026gt; part2)); then return 1 elif ((part1 \u0026lt; part2)); then return 2 fi done return 0 } # 示例版本号 version1=\u0026#34;1.2.3\u0026#34; version2=\u0026#34;1.2.4\u0026#34; # 调用比较函数 compare_versions \u0026#34;$version1\u0026#34; \u0026#34;$version2\u0026#34; result=$? # 输出比较结果 if [ $result -eq 0 ]; then echo \u0026#34;版本号 $version1 等于 $version2\u0026#34; elif [ $result -eq 1 ]; then echo \u0026#34;版本号 $version1 大于 $version2\u0026#34; else echo \u0026#34;版本号 $version1 小于 $version2\u0026#34; fi 返回结果：\n返回 0 表示两个版本号相等。 返回 1 表示第一个版本号大于第二个版本号。 返回 2 表示第一个版本号小于第二个版本号。 ","date":"2024-08-28T17:11:01+08:00","permalink":"http://localhost:1313/p/shell-compare-version/","title":"shell比较版本号大小"},{"content":" 背景\r解决无网络环境下安装python包的问题 解决跨架构下安装python包，如x86环境下载arm架构下的pip包 解决方案\r在线下载包及其依赖\r通过 `PyPI官网 下载所需的包。这种方式对于没有依赖或依赖较少的包较为方便。但对于依赖众多的包，需要逐个下载，过程较为繁琐。\n使用pip下载\r准备联网环境\n首先确保有一个可以访问互联网的环境,最好是相同python版本和架构\n下载包及其依赖：\n使用以下命令下载所需的单个包和它的所有依赖： 1 pip3 download -d pip-package -i https://pypi.tuna.tsinghua.edu.cn/simple requests 其中，-d 参数指定下载目录。 -i 参数指定使用清华镜像源以加速下载。 跨架构安装：\n对于需要在不同架构之间安装包的情况，首先在目标架构的环境下使用上述方法下载包。 然后将下载好的包复制到目标环境中进行安装。 注意事项\r确保下载的包与系统中Python的版本和架构相兼容。 如果遇到下载速度慢或失败的问题，可以尝试更换其他镜像源，如阿里云、中国科技大学等提供的镜像源。 在使用pip下载包时，注意检查网络连接，以免下载中断导致安装失败。 ","date":"2024-08-26T17:29:34+08:00","permalink":"http://localhost:1313/p/pip-offline-package/","title":"pip制作离线包"},{"content":" docker启动所有已经停止的容器\r1 docker start $(docker ps -a | awk \u0026#39;{ print $1}\u0026#39; | tail -n +2) docker删除正在运行的单个容器\r1 docker rm -f \u0026lt;container_id\u0026gt; docker删除正在运行的所有容器\r1 docker rm -f $(docker ps -q) ","date":"2024-08-22T17:14:23+08:00","permalink":"http://localhost:1313/p/docker-command/","title":"Docker命令大全"},{"content":" 卸载旧版本docker\r1 2 3 4 5 6 7 8 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装依赖\r1 yum install -y yum-utils 配置yum docker源\r1 2 3 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装docker\r1 yum install docker-ce docker-ce-cli containerd.io 启动docker\r1 systemctl start docker ","date":"2024-08-22T16:40:12+08:00","permalink":"http://localhost:1313/p/centos-install-docker/","title":"Centos7安装docker"}]