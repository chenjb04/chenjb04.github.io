[{"content":" 在 CentOS 7 上升级 GCC 版本可以通过多种方法实现, 这里使用个人认为最简单的方式升级，CentOS SCL\n环境信息\rCentos7 gcc4.8.5 -\u0026gt;gcc8.3.1 安装SCL仓库\r1 yum install centos-release-scl 配置SCL仓库源\r由于scl源在国外，有时候安装很慢，这里把源换成国内阿里源\n修改CentOS-SCLo-scl.repo 1 2 3 4 # 备份 mv /etc/yum.repos.d/CentOS-SCLo-scl.repo /etc/yum.repos.d/CentOS-SCLo-scl.repo.bak # 写入阿里源 vim /etc/yum.repos.d/CentOS-SCLo-scl.repo 内容如下：\n1 2 3 4 5 6 7 [centos-sclo-sclo] name=CentOS-7 - SCLo sclo baseurl=https://mirrors.aliyun.com/centos/7/sclo/x86_64/sclo/ # mirrorlist=http://mirrorlist.centos.org?arch=$basearch\u0026amp;release=7\u0026amp;repo=sclo-sclo gpgcheck=0 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-SC 修改CentOS-SCLo-scl-rh.repo 1 2 3 4 # 备份 mv /etc/yum.repos.d/CentOS-SCLo-scl-rh.repo /etc/yum.repos.d/CentOS-SCLo-scl-rh.repo.bak # 写入阿里源 vim /etc/yum.repos.d/CentOS-SCLo-scl-rh.repo 内容如下：\n1 2 3 4 5 6 7 [centos-sclo-rh] name=CentOS-7 - SCLo rh baseurl=https://mirrors.aliyun.com/centos/7/sclo/x86_64/rh/ # mirrorlist=http://mirrorlist.centos.org?arch=$basearch\u0026amp;release=7\u0026amp;repo=sclo-rh gpgcheck=0 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-SCLo 清理缓存\n1 yum clean all 安装gcc8\r1 yum install devtoolset-8 临时启用devtoolset-8\r1 scl enable devtoolset-8 bash 这将启动一个新的shell会话，其中gcc将指向 devtoolset-8 提供的 GCC 版本\n验证gcc版本\r1 gcc --version 输出类似于：gcc version 8.3.1 20190311 (Red Hat 8.3.1-3) (GCC)\n注意\r使用scl是临时启用的shell，只有在当前shell中gcc版本才是8.3.1，不是全局生效的，不建议全局生效，因为不同软件的编译依赖gcc版本不同，使用scl能完美解决不同gcc版本的使用问题\n","date":"2024-09-20T09:35:36+08:00","permalink":"http://localhost:1313/p/centos-update-gcc/","title":"centos7升级GCC版本"},{"content":" 环境\rCentos7 Python3.12.6 下载Python源码\r访问Python的官方网站，下载最新的源码包,这里下载的是Python3.12.6\n1 wget https://www.python.org/ftp/python/3.12.6/Python-3.12.6.tgz 解压源码包\r1 2 tar xzf Python-3.12.6.tgz cd Python-3.12.6 编译安装\r1 ./configure --enable-optimizations --prefix=/opt/python3.12.6 --enable-optimizations 选项用于启用额外的优化，使 Python 运行更快。 --prefix 指定python安装目录 1 make altinstall make altinstall用于避免覆盖系统默认的 Python 版本。 可能遇到的问题\r这是因为使用了--enable-optimizations,而gcc版本4.x比较低导致的，这里可以去掉这个参数编译，也可以升级gcc版本到8.x以上，建议升级gcc版本，参考升级gcc文章，centos7升级GCC版本\n验证安装\r1 /opt/python3.12.6/bin/python3.12 能够直接进入python shell\n设置软链接\r1 ln -s /opt/python3.12.6/bin/python3.12 /usr/bin/python3.12 设置软链接后，终端可以直接python3.12执行\n设置pip\rpip默认安装了，只需要设置下软链接即可\n1 ln -s /opt/python3.12.6/bin/pip3.12 /usr/bin/pip3.12 ","date":"2024-09-14T14:34:35+08:00","permalink":"http://localhost:1313/p/centos-compile-python3/","title":"centos7编译安装Python3.12.6"},{"content":" 下载源代码\r从nmap官方网站下载源代码: nmap,这里我下载的是nmap-7.95.tar.bz2(bzip2 压缩)\n1 2 3 4 5 6 # 使用wget或curl下载源代码（此处为示例命令） wget https://nmap.org/dist/nmap-7.95.tar.bz2 # 解压 bzip2 -cd nmap-7.95.tar.bz2 | tar xvf - # 进入创建的目录 cd nmap-7.95 配置编译环境\r在编译之前，运行 configure 脚本来配置编译环境。\n1 ./configure ./configure 中有几个重要的参数\n--prefix=\u0026lt;directoryname\u0026gt; 决定了 Nmap 及其组件的安装位置 --without-zenmap 此选项可不安装 Zenmap 图形GUI，zenmap依赖python环境 --with-openssl=\u0026lt;directoryname\u0026gt; 指定OpenSSL库的位置 --with-libpcap=\u0026lt;directoryname\u0026gt; 指定Libpcap库的位置，用于捕获网络数据包。 --with-libpcre=\u0026lt;directoryname\u0026gt; 指定PCRE（Perl兼容正则表达式）库的位置。 --with-libdnet=\u0026lt;directoryname\u0026gt; 指定Libdnet网络库的位置，用于数据包操作。 这里我不需要可视化GUI，所以指定了\u0026ndash;without-zenmap`\n1 ./configure --prefix=/usr/local/nmap7.95 --without-zenmap 没有报错即为成功\n可能遇到的问题\r缺失gcc 安装一下\n1 dnf install gcc 编译\r1 make 如果没有make命令，需要安装一下\n1 dnf install make 可能遇到的问题\r1.缺失gcc-c++\n安装\n1 dnf install gcc-c++ 注意: make 编译失败时，处理完错误后，需要make clean清理一下，在重新执行make\n安装\r1 make install 验证\r1 /usr/local/nmap7.95/bin/nmap --version 看到以下结果即为成功\n如果希望在任何位置都能直接通过nmap命令访问Nmap，可以添加一个软链接到系统路径中。\n1 ln -s /usr/local/nmap7.95/bin/nmap /usr/sbin/nmap 加入软链接后.可以在任何位置运行以下命令来检查Nmap版本\n1 nmap --version ","date":"2024-09-13T14:44:31+08:00","permalink":"http://localhost:1313/p/arm-nmap-compile/","title":"ARM架构下编译安装nmap7.95"},{"content":" 在python中删除列表中元素是比较常见的操作，删除的方法也比较多，这里列一下最常见的做法\npop方法\rpop()方法用于删除指定位置的元素，默认删除最后一个元素，返回值为该元素。如果索引超出范围，引发IndexError异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;] # 删除索引为1的元素 remove_element = l.pop(1) print(remove_element) # lisi print(l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;] # 删除最后一个元素 remove_element = l.pop() print(remove_element) # zhaoliu print(l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;] # 删除超过索引的元素 remove_element = l.pop(10) # IndexError: pop index out of range 注意：\n需要知道要删除元素的指定索引位置。 索引超出范围，会抛出异常 使用场景\n适用于需要删除特定位置元素的场景，尤其是删除最后一个元素时。 remove方法\rremove()方法用于删除匹配到的第一个元素，无返回值。如果要删除的元素不存在，引发ValueError异常\n1 2 3 4 5 6 7 8 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除lisi l.remove(\u0026#39;lisi\u0026#39;) print(l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除不存在的元素 l.remove(\u0026#39;xxx\u0026#39;) # ValueError: list.remove(x): x not in list 注意：\nremove只会删除第一个匹配到的元素，如果有多个相同的元素要删除，那么remove就不太适用 删除不存在的元素，会抛出异常 使用场景\n适用于删除已知值的元素，且列表中该值不重复或只需删除第一个匹配项的场景。 del语句\rdel和pop()方法类似，都是用于删除指定索引位置的元素，但是del更灵活一些，可以删除指定位置的切片，索引超出范围，会引发IndexError异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除索引为1的元素 del l[1] print(l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除索引0-2的切片 del l[0:2] print(l) # [\u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除不存在的索引 del l[100] print(l) # IndexError: list assignment index out of range 注意：\n要知道要删除元素的指定索引位置 索引超出范围，会抛出异常 使用场景\n适用于删除特定位置或范围内的元素。 列表推导式\r可以创建一个新列表，用于删除想删除的元素，比较灵活\n1 2 3 4 5 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除lisi new_l = [element for element in l if element != \u0026#39;lisi\u0026#39;] print(new_l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;] 注意：\n这种方式不能原地删除，需要创建新列表，开辟新的内存空间 列表非常大的情况，效率比较低，内存占用比较大 使用场景\n适用于需要删除多个相同元素或复杂条件删除的场景。 filter函数\rfilter函数和列表推导式方式很像，但是filter函数是一个迭代器，内存效率高，处理大数据集时更高效\n1 2 3 4 5 l = [\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;, \u0026#39;lisi\u0026#39;] # 删除lisi new_l = list(filter(lambda x: x != \u0026#39;lisi\u0026#39;, l)) print(new_l) # [\u0026#39;zhangsan\u0026#39;, \u0026#39;wangwu\u0026#39;, \u0026#39;zhaoliu\u0026#39;] 注意：\n这种方式不能原地删除，需要创建新列表，开辟新的内存空间 使用场景\n适用于需要删除多个相同元素或复杂条件删除的场景，尤其是处理大数据集时。 总结\r方法 使用场景 优点 缺点 pop 删除特定位置元素，尤其是最后一个元素 操作简单，返回被删除的元素 需要知道索引，索引超出范围会抛出异常 remove 删除已知值的元素 不需要知道索引 只能删除第一个匹配项，删除不存在的元素会抛出异常 del 删除特定位置或范围内的元素 可以删除切片，灵活性高 需要知道索引，索引超出范围会抛出异常 列表推导式 删除多个相同元素或复杂条件删除 灵活性高 需要创建新列表，内存占用较大，处理大数据集时效率较低 filter 删除多个相同元素或复杂条件删除，处理大数据集 内存效率高，适合处理大数据集 需要创建新列表，不能原地删除 ","date":"2024-09-03T19:28:27+08:00","permalink":"http://localhost:1313/p/python-list-remove/","title":"Python 列表删除元素"},{"content":" 在shell脚本中比较版本号大小是一种常见的任务，尤其是在漏洞检测中，对比版本号，判断漏洞是否存在。版本号通常由主版本号、次版本号和补丁号组成，格式可能是major.minor.patch。有时，版本号可能还包括预发布标签（如alpha或beta）或构建元数据。\n以下是一个示例shell脚本，用于比较两个版本号的大小：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #!/bin/bash # 比较两个版本号的函数 compare_versions() { local version1=$1 local version2=$2 # 将版本号分割成数组 IFS=\u0026#39;.\u0026#39; read -r -a ver1 \u0026lt;\u0026lt;\u0026lt; \u0026#34;$version1\u0026#34; IFS=\u0026#39;.\u0026#39; read -r -a ver2 \u0026lt;\u0026lt;\u0026lt; \u0026#34;$version2\u0026#34; # 获取最大数组长度 local max_len=${#ver1[@]} if [ ${#ver2[@]} -gt $max_len ]; then max_len=${#ver2[@]} fi # 比较每一部分 for ((i=0; i\u0026lt;max_len; i++)); do # 如果某个版本号部分不存在，则视为0 local part1=${ver1[i]:-0} local part2=${ver2[i]:-0} if ((part1 \u0026gt; part2)); then return 1 elif ((part1 \u0026lt; part2)); then return 2 fi done return 0 } # 示例版本号 version1=\u0026#34;1.2.3\u0026#34; version2=\u0026#34;1.2.4\u0026#34; # 调用比较函数 compare_versions \u0026#34;$version1\u0026#34; \u0026#34;$version2\u0026#34; result=$? # 输出比较结果 if [ $result -eq 0 ]; then echo \u0026#34;版本号 $version1 等于 $version2\u0026#34; elif [ $result -eq 1 ]; then echo \u0026#34;版本号 $version1 大于 $version2\u0026#34; else echo \u0026#34;版本号 $version1 小于 $version2\u0026#34; fi 返回结果：\n返回 0 表示两个版本号相等。 返回 1 表示第一个版本号大于第二个版本号。 返回 2 表示第一个版本号小于第二个版本号。 ","date":"2024-08-28T17:11:01+08:00","permalink":"http://localhost:1313/p/shell-compare-version/","title":"shell比较版本号大小"},{"content":" 背景\r解决无网络环境下安装python包的问题 解决跨架构下安装python包，如x86环境下载arm架构下的pip包 解决方案\r在线下载包及其依赖\r通过 `PyPI官网 下载所需的包。这种方式对于没有依赖或依赖较少的包较为方便。但对于依赖众多的包，需要逐个下载，过程较为繁琐。\n使用pip下载\r准备联网环境\n首先确保有一个可以访问互联网的环境,最好是相同python版本和架构\n下载包及其依赖：\n使用以下命令下载所需的单个包和它的所有依赖： 1 pip3 download -d pip-package -i https://pypi.tuna.tsinghua.edu.cn/simple requests 其中，-d 参数指定下载目录。 -i 参数指定使用清华镜像源以加速下载。 跨架构安装：\n对于需要在不同架构之间安装包的情况，首先在目标架构的环境下使用上述方法下载包。 然后将下载好的包复制到目标环境中进行安装。 注意事项\r确保下载的包与系统中Python的版本和架构相兼容。 如果遇到下载速度慢或失败的问题，可以尝试更换其他镜像源，如阿里云、中国科技大学等提供的镜像源。 在使用pip下载包时，注意检查网络连接，以免下载中断导致安装失败。 ","date":"2024-08-26T17:29:34+08:00","permalink":"http://localhost:1313/p/pip-offline-package/","title":"pip制作离线包"},{"content":" docker启动所有已经停止的容器\r1 docker start $(docker ps -a | awk \u0026#39;{ print $1}\u0026#39; | tail -n +2) docker删除正在运行的单个容器\r1 docker rm -f \u0026lt;container_id\u0026gt; docker删除正在运行的所有容器\r1 docker rm -f $(docker ps -q) ","date":"2024-08-22T17:14:23+08:00","permalink":"http://localhost:1313/p/docker-command/","title":"Docker命令大全"},{"content":" 卸载旧版本docker\r1 2 3 4 5 6 7 8 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装依赖\r1 yum install -y yum-utils 配置yum docker源\r1 2 3 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装docker\r1 yum install docker-ce docker-ce-cli containerd.io 启动docker\r1 systemctl start docker ","date":"2024-08-22T16:40:12+08:00","permalink":"http://localhost:1313/p/centos-install-docker/","title":"Centos7安装docker"}]